import groovy.json.JsonBuilder
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
	alias(libs.plugins.androidJUnit5)
	alias(libs.plugins.kotlinSerialization)
}

apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'org.jetbrains.kotlin.android'
apply plugin: 'kotlin-parcelize'
apply plugin: 'org.jetbrains.kotlin.plugin.compose'

def androidKeyStorePassword = hasProperty('androidKeyStorePassword') ? androidKeyStorePassword : null
def hasKeyStorePassword = { androidKeyStorePassword != null && !androidKeyStorePassword.isEmpty() }
if (!hasKeyStorePassword()) {
	androidKeyStorePassword = System.getenv('ANDROID_KEY_STORE_PASSWORD')
}

def androidStorePassword = hasProperty('androidStorePassword') ? androidStorePassword : ""
def hasAndroidStorePassword = { androidStorePassword != null && !androidStorePassword.isEmpty() }
if (!hasAndroidStorePassword()) {
	androidStorePassword = System.getenv('ANDROID_STORE_PASSWORD')
}

def isSignedExternally = { hasKeyStorePassword() && hasAndroidStorePassword() }

def printDependenciesTask = tasks.register("printDependencies") {
	group = "build"
	final def outputFile = file("$temporaryDir/raw/dependencies.json")

	outputs.dir(temporaryDir)

	// 2. Use a Provider to get the configuration and .map() to transform it
	//    into a simple, serializable list of maps. This happens lazily.
//	def dependenciesProvider = project.configurations.allDependencies
//		.map { artifacts ->
//			artifacts.collect { artifact ->
//				def componentId = artifact.id.componentIdentifier
//				return [group: componentId.group, name: componentId.displayName, version: componentId.version]
//			}
//		}

	// 1. Define project group and name outside the provider block.
	def projectGroup = project.group
	def projectName = project.name

	def dependenciesProvider = project.provider {
		// 2. Iterate over all configurations and their declared dependencies.
		project.configurations
			.collect { config ->
				config.allDependencies.collect { dep ->
					// 3. Create a map for each dependency with its details.
					return [group: dep.group, name: dep.name, version: dep.version]
				}
			}
			.flatten()
			.findAll { it.group != projectGroup || it.name != projectName || !it.group.startsWith("com.android") } // Filter out nulls and the project itself.
			.unique() // 4. Flatten the list and remove duplicates.
	}

	doLast {
		// 3. In the execution phase, get the final value from the provider.
		def dependenciesList = dependenciesProvider.get()

		def json = new JsonBuilder([dependencies: dependenciesList])
		def prettyJson = json.toString() // Or json.toString() for a compact version

		def indexFile = outputFile
		indexFile.parentFile.mkdirs()
		indexFile << prettyJson
	}
}

android {
    compileSdk 36

    defaultConfig {
        minSdkVersion 21
        targetSdkVersion 36
		versionName gitVersion()
		base.archivesName = "project-blue-" + gitVersion()
	}

	signingConfigs {
		debug {
			// You need to specify either an absolute path or include the
			// keystore file in the same directory as the build.gradle file.
			storeFile file("androidstore")
			storePassword androidStorePassword
			keyAlias "store"
			keyPassword androidKeyStorePassword
		}
		release {
			// You need to specify either an absolute path or include the
			// keystore file in the same directory as the build.gradle file.
			storeFile file("androidstore")
			storePassword androidStorePassword
			keyAlias "store"
			keyPassword androidKeyStorePassword
		}
	}

	buildFeatures {
		compose = true
		buildConfig = true
	}

	compileOptions {
        sourceCompatibility JavaVersion.VERSION_11
        targetCompatibility JavaVersion.VERSION_11

		coreLibraryDesugaringEnabled = true
	}

	kotlinOptions {
		jvmTarget = '11'
	}

	sourceSets {
		main {
			res.srcDirs += printDependenciesTask.map { it.temporaryDir }
		}
	}

	buildTypes {
        debug {
            minifyEnabled false
			signingConfig = (isSignedExternally() ? signingConfigs.debug : signingConfig)
		}
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
			signingConfig (isSignedExternally() ? signingConfigs.release : signingConfig)
			ndk {
				debugSymbolLevel = 'SYMBOL_TABLE'
			}
        }
    }

    packagingOptions {
        resources {
            excludes += ['META-INF/LICENSE.txt', 'META-INF/NOTICE.txt', 'META-INF/INDEX.LIST']
			resources {
				excludes += '/META-INF/{AL2.0,LGPL2.1}'
			}
		}
    }

    defaultConfig {

		versionCode getGeneratedVersionCode()
		testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
		vectorDrawables {
			useSupportLibrary true
		}
	}

    testOptions {
        unitTests {
            includeAndroidResources = true
            returnDefaultValues = true
			all {
				maxHeapSize = "2048m"
				maxParallelForks = 3
			}
		}
	}

    lint {
        abortOnError false
    }

	namespace 'com.lasthopesoftware.bluewater'
}

tasks.withType(KotlinCompile).configureEach {
	compilerOptions {
		freeCompilerArgs.add("-opt-in=kotlin.RequiresOptIn")
	}
}

preBuild.dependsOn("printDependencies")

def gitVersion() {
	try {
		def gitDescribe = providers.exec {
			it.ignoreExitValue = true
			commandLine("git", "describe")
		}.standardOutput.asText.get().trim()

		def latestTag = providers.exec {
			it.ignoreExitValue = true
			commandLine("git", "describe", "--abbrev=0")
		}.standardOutput.asText.get().trim()

		if (gitDescribe != latestTag) {
			return latestTag + "-SNAPSHOT"
		}

		return gitDescribe
	} catch (ignored) {
		return "0.0.1"
	}
}

def getGeneratedVersionCode() {
    // should result in the same value as running
    // git rev-list <checked out branch name> | wc -l
    def initialVersionCode = 3761 // the initial version code before tags were used to increment version code

	try {
		def numberOfReleases = providers.exec {
			it.ignoreExitValue = true
			commandLine("sh", "-c", "git tag | wc -l")
		}.standardOutput.asText.get() as Integer
		return numberOfReleases + initialVersionCode
	} catch (ignored) {
		return initialVersionCode
	}
}

dependencies {
	coreLibraryDesugaring libs.desugar.jdk.libs

	implementation libs.core.ktx
	implementation libs.annotation
	implementation libs.work.runtime
	implementation libs.media
	implementation libs.palette.ktx
	implementation libs.preference.ktx
	implementation libs.lifecycle.viewmodel.ktx
	implementation libs.lifecycle.process
	implementation libs.lifecycle.service
	implementation libs.lifecycle.runtime.ktx
	implementation libs.startup.runtime
	implementation libs.material
	implementation libs.guava
	implementation libs.joda.time
	implementation libs.commons.io
	implementation libs.slf4j.api
	implementation libs.logback.android
	implementation libs.handoff
	implementation libs.rxjava
	implementation libs.lazy.j
	implementation libs.jsoup
	implementation libs.media3.exoplayer
	implementation libs.media3.datasource.okhttp
	implementation libs.okio
	implementation libs.okhttp
	implementation libs.querydroid
	implementation libs.compose.ui
	implementation libs.compose.material
	implementation libs.compose.runtime.rxjava3
	implementation libs.activity.compose
	implementation libs.reimagined
	implementation libs.gson
	implementation libs.kotlinx.coroutines.rx3
	implementation libs.compose.ui.tooling
	debugImplementation libs.compose.ui.test.manifest
	testCompileOnly libs.junit
	testImplementation libs.commons.codec
	testImplementation libs.junit.jupiter.api
	testImplementation libs.assertj.core
	testImplementation libs.robolectric
	testImplementation libs.junit.ktx
	testImplementation libs.core
	testImplementation libs.runner
	testImplementation libs.mockk
	testImplementation libs.kotlinx.coroutines.test
	testImplementation libs.compose.ui.test.junit4
	testRuntimeOnly libs.junit.platform.launcher
	testRuntimeOnly libs.junit.vintage.engine
}
